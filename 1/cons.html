<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ECS</title>
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<header>
		<a href="index.html">Что такое ECS</a>
		<a href="pros.html">Преимущества</a>
		<a href="cons.html">Недостатки</a>
		<a href="">A</a>
	</header>

	<h1>Недостатки ECS</h1>
	<p>Рассмотрим недостатки использования Entity Component System в разработке игр.</p>

	<h2>Высокий порог вхождения</h2>
	<p>Несмотря на&nbsp;то, что сам концепт ECS можно описать в&nbsp;одном предложении, чтобы научиться варить его правильно может потребоваться много практики. ECS требует от&nbsp;вас забыть всё, что вы&nbsp;знали о&nbsp;проектировании раньше: все ваши вертикальные иерархии наследования, что поведение объекта определяется его интерфейсом, что объект представляет собой <nobr>что-то</nobr> конкретное и&nbsp;неизменяемое, что у&nbsp;объекта может быть личное (private) пространство, а&nbsp;логика может быть вызвана где только захочется.</p>
	<p>В&nbsp;ECS всё не&nbsp;так, он&nbsp;полная противоположность описанному выше. Тут все данные открыты, все сущности абстрактны и&nbsp;очень динамичны, их&nbsp;свойства лежат в&nbsp;одной плоскости и&nbsp;доступным каждому, логика работает по&nbsp;принципу конвейера, а&nbsp;поведение сущностей вообще меняется на&nbsp;ходу исходя из&nbsp;данных.</p>
	<blockquote>На&nbsp;перестроение головы под это уходит время и&nbsp;пока этого не&nbsp;произойдет, ваш мозг будет активно сопротивляться, особенно если у&nbsp;вас за&nbsp;спиной большой опыт разработки. Он&nbsp;будет хотеть выстраивать наследование компонентов, делать им&nbsp;интерфейсы и&nbsp;методы, а&nbsp;также много всего другого.</blockquote>

	<h2>Слабая связность может мешать</h2>
	<p>Если вам вдруг понадобилось тесное взаимодействие между двумя конкретными сущностями (например, гусеничный корпус и&nbsp;башня танка), то&nbsp;вы&nbsp;сталкиваетесь с&nbsp;проблемой, что сущности то&nbsp;у&nbsp;нас максимально абстрактны и&nbsp;вы&nbsp;не&nbsp;можете гарантировать на&nbsp;уровне компилятора, что на&nbsp;другом конце будет именно гусеничный корпус. Это будет мешать, так как игры&nbsp;&mdash; место, где много тесных взаимодействий, и&nbsp;всегда хочется иметь прямую ссылку с&nbsp;гарантией свойств и&nbsp;поведения. Надо будет проверять наличие компонента и&nbsp;<nobr>как-то</nobr> обрабатывать его отсутствие, получать доступ к&nbsp;компоненту из&nbsp;сущности, чтобы начать с&nbsp;ним взаимодействовать&hellip;</p>
	<p>Но, возвращаясь к&nbsp;слабой связности как преимуществу: это научит вас организовывать свой код так, чтобы на&nbsp;другом конце могла быть любая сущность, которую можно толкнуть отдачей и&nbsp;даже предусмотреть случай отсутствия такого компонента, чтобы игра всё равно смогла работать корректно без необходимости менять код, если вдруг ваш геймдиз захотел установить башню танка на&nbsp;здание.</p>

	<h2>Доступ к любым данным откуда угодно</h2>
	<blockquote>Мир ECS представляет собой полностью открытые коробки сущностей с&nbsp;доступными каждому данными в&nbsp;компонентах. Это, как и&nbsp;слабая связность выше, одновременно и&nbsp;плюс, и&nbsp;минус ECS.</blockquote>
	<p>С&nbsp;одной стороны это дико удобно, ибо не&nbsp;нужно придумывать как обходить созданные ранее при проектировании ограничивающие самого себя рамки (&laquo;X&nbsp;не&nbsp;должен знать об&nbsp;Y&raquo;), пытаясь натянуть сову на&nbsp;глобус и&nbsp;вытаскивая в&nbsp;public сокрытые ранее данные для решения <nobr>какой-то</nobr> сиюминутной задачи.</p>
	<p>С&nbsp;другой стороны, любой неопытный программист так и&nbsp;норовит изменить данные оттуда, откуда этого делать не&nbsp;стоит, но&nbsp;обычно командное взаимодействие включает в&nbsp;себя доверие к&nbsp;работе других, так что доверяй, но&nbsp;проверяй ;)</p>
	<footer>
		Контент взят со <a href="https://habr.com/ru/articles/665276/">статьи на Хабре</a>
	</footer>
</body>

</html>