<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ECS</title>
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<header>
		<a href="index.html">Что такое ECS</a>
		<a href="pros.html">Преимущества</a>
		<a href="cons.html">Недостатки</a>
	</header>

	<h1>Преимущества ECS</h1>
	<p>Рассмотрим преимущества использования Entity Component System в разработке игр.</p>

	<h2>Слабая связность кода</h2>
	<p><b>Это крайне полезное для игроделов свойство.</b> Оно позволяет нам производить рефакторинг и&nbsp;расширение кодовой базы относительно просто и&nbsp;не&nbsp;ломая старых кусков кода. Мы&nbsp;всегда можем добавить новое поведение с&nbsp;использованием старых данных буквально сбоку, без нужды <nobr>как-либо</nobr> вмешиваться в&nbsp;старую логику. ECS достигает такого эффекта благодаря тому, что все взаимодействие логики выражено данными в&nbsp;Entity, которая в&nbsp;свою очередь является максимально абстрактным объектом без <nobr>каких-либо</nobr> гарантий, как <nobr>какой-нибудь</nobr> Object в&nbsp;C#/Java.</p>
	<p>Однако стоит иметь в виду, что в&nbsp;ECS порядок изменения данных (то&nbsp;есть порядок выполнения систем) играет важную роль, что в&nbsp;конечном счете может повлиять на&nbsp;сложность рефакторинга и&nbsp;таки поломать вашу старую логику, <nobr>а то</nobr> и&nbsp;создать неприятные <nobr>сайд-эффект</nobr> баги, об&nbsp;этом ещё поговорим в&nbsp;Недостатках.</p>
	<p>Свойство <b>&laquo;всё есть данные&raquo;</b> даёт нам ещё одно прекрасное преимущество: если всё взаимодействие выражено в&nbsp;чистых данных&nbsp;&mdash; наша логика всегда полностью отвязана от&nbsp;источника данных. Это позволяет нам как безболезненно перемещать логику из&nbsp;проекта в&nbsp;проект и&nbsp;использовать повторно (с&nbsp;сохранением формата данных, ессесно), так и&nbsp;запускать логику на&nbsp;<nobr>каких-угодно</nobr> вводных данных для тестирования ее&nbsp;работы.</p>

	<h2>Комбинаторика свойств</h2>
	<p>Это преимущество очень обрадует ваших геймдизов. Именно это преимущество и&nbsp;делает ECS отличным вариантом для описания динамических миров. Вы&nbsp;только представьте: вы&nbsp;можете придать любое свойство (а&nbsp;следовательно и&nbsp;логику) любой вашей сущности без <nobr>какого-либо</nobr> геморроя!</p>
	<p>Захотели, чтобы у&nbsp;камеры появилось здоровье&nbsp;&mdash; пожалуйста, повесил на&nbsp;сущность камеры HealthComponent и&nbsp;готово: она может получать урон (если есть такая система). Повесил на&nbsp;сущность InFireComponent и&nbsp;она тут&nbsp;же начинает получать урон от&nbsp;горения, если у&nbsp;нее есть HealthComponent, красота! Нужно чтобы дом начал двигаться под управлением игрока? Да&nbsp;без проблем, где там мой PlayerInputListenerComponent&hellip;</p>
	<blockquote>Опытный разработчик тут заметит: &laquo;Пфф, с&nbsp;этим справится большинство Composition over Inheritance паттернов, чем тут ECS лучше?&raquo;.<br>Отвечаю: ECS позволяет вам комбинировать свойства не&nbsp;только с&nbsp;точки зрения формирования сущности, но&nbsp;и&nbsp;для создания специфичной логики при комбинации нескольких свойств (компонентов) на&nbsp;одной сущности. Не&nbsp;говоря уже о&nbsp;возможности добавить совсем новую логику для старых данных без необходимости трогать компоненты на&nbsp;сущности.</blockquote>

	<h2>ESC может дать прирост производительности</h2>
	<p>Многие считают, что хорошая производительность&nbsp;&mdash; основное преимущество ECS (спасибо пропаганде Unity). Это не&nbsp;совсем так. Скорость выполнения кода лишь приятный бонус, вытекающий из&nbsp;принципов паттерна: данные в&nbsp;одном месте&nbsp;&mdash; логика в&nbsp;другом + работа систем в&nbsp;духе SIMD (single instruction, multiple data), когда мы&nbsp;выполняем одну и&nbsp;ту&nbsp;же логику для множества одинаковых компонентов. А&nbsp;если фреймворк следует DOD при реализации ECS и&nbsp;добивается хорошей локальности данных, то&nbsp;мы&nbsp;дополнительно получаем <nobr>кэш-френдли</nobr> код, что однозначно порадует ваш процессор.</p>
	<p>Ключевое слово этого пункта&nbsp;&mdash; <b>&laquo;может&raquo;</b>. Итоговая производительность ECS зависит от&nbsp;множества факторов: как именно фреймворк хранит данные, как фреймворк фильтрует сущности, насколько быстрый доступ систем к&nbsp;данным, ну&nbsp;и, конечно&nbsp;же, насколько быстро работает код внутри ваших систем. При этом последний пункт для большинства проектов дает самое большое влияние на&nbsp;время обработки кадра.</p>
	<p>Однако, если взглянуть в&nbsp;контексте разработки на&nbsp;Unity, ECS всегда будет быстрее привычного <nobr>MonoBehaviour-подхода</nobr>, особенно на&nbsp;большом объеме данных. Но&nbsp;не&nbsp;забывайте, что <nobr>всё-таки</nobr> главное в&nbsp;производительности вашей игры не&nbsp;столько архитектурный паттерн или производительность фреймворка, сколько алгоритмическая сложность и&nbsp;производительность написанного вами кода.</p>
	<blockquote>Да пребудет с вами Профайлер!</blockquote>

	<footer>
		Контент взят со <a href="https://habr.com/ru/articles/665276/">статьи на Хабре</a>
	</footer>
</body>

</html>