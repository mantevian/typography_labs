<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ECS</title>
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<header>
		<a href="index.html">Что такое ECS</a>
		<a href="pros.html">Преимущества</a>
		<a href="cons.html">Недостатки</a>
	</header>

	<h1>Что такое ECS</h1>
	<p><b>Entity Component System</b>&nbsp;&mdash; это архитектурный паттерн, созданный специально для разработки игр, он&nbsp;отлично подходит для описания динамического виртуального мира. <nobr>Из-за</nobr> его особенностей некоторые считают его чуть&nbsp;ли не&nbsp;новой парадигмой программирования, это скорее не&nbsp;так, но&nbsp;мозг перестраивать, скорее всего, потребуется. ECS возводит в&nbsp;абсолют принцип Composition over inheritance (композиция важнее наследования) и&nbsp;может являться частным примером Data oriented design (ориентированного на&nbsp;данные дизайна), однако это уже зависит от&nbsp;интерпретации паттерна конкретной реализацией.</p>

	<h2>Расшифровка названия</h2>
	<p><b>Entity</b>&nbsp;&mdash; сущность, максимально абстрактный объект. Условный контейнер для свойств, определяющих чем будет являться эта сущность. Зачастую представляется в&nbsp;виде идентификатора для доступа к&nbsp;данным.</p>
	<p><b>Component</b>&nbsp;&mdash; компонент, свойство с&nbsp;данными объекта. Компоненты в&nbsp;ECS должны содержать исключительно чистые данные, без единой капли логики. Тем не&nbsp;менее часть разработчиков допускает использование разнообразных геттеров и&nbsp;сеттеров в&nbsp;компонентах, но&nbsp;лично я&nbsp;считаю, что для этих целей лучше подходят static utils.</p>
	<p><b>System</b>&nbsp;&mdash; система, логика обработки данных. Системы в&nbsp;ECS не&nbsp;должны содержать никаких данных, только логика обработки данных. Но, опять&nbsp;же, часть разработчиков допускают это, чтобы определять некоторое вспомогательное поведение самой системы, например, константы или различного рода вспомогательные сервисы.</p>

	<blockquote>Наверняка, на&nbsp;этом месте у&nbsp;вас уже возник вопрос: &laquo;А&nbsp;зачем мне этот ваш ECS вообще нужен? Какая от&nbsp;него польза?&raquo;. И&nbsp;чтобы помочь вам определиться читать&nbsp;ли вообще статью дальше, я&nbsp;расскажу чем лично мне так полюбился ECS.</blockquote>

	<h2>Просто делаешь игру</h2>
	<p><b>С&nbsp;ECS ты&nbsp;просто садишься и&nbsp;делаешь игру</b>, а&nbsp;не&nbsp;воюешь с&nbsp;архитектурой проекта. Нет нужды строить большие и&nbsp;&laquo;красивые&raquo; иерархии, продумывать кучу связей и&nbsp;париться про &laquo;X&nbsp;же не&nbsp;должен знать про Y&raquo;. При этом принципы ECS защищают тебя (не&nbsp;на&nbsp;100%, ессесно) от&nbsp;безвыходной ситуации, в&nbsp;которую заводит плохая архитектура, когда дальнейшее развитие проекта становится очень болезненным. И&nbsp;даже если <nobr>всё-таки</nobr>
		<nobr>что-то</nobr> пошло не&nbsp;так&nbsp;&mdash; рефакторинг в&nbsp;ECS совсем не&nbsp;проблема. И&nbsp;это, на&nbsp;мой взгляд, самое кайфовое в&nbsp;ECS.
	</p>
	<p><b>Код на&nbsp;ECS получается простым и&nbsp;понятным.</b> Не&nbsp;нужно ползать по&nbsp;куче вызовов среди кучи классов, чтобы понять чем занимается конкретная система, всё видно сразу, особенно если грамотно разбивать фичу на&nbsp;системы, системы на&nbsp;методы и&nbsp;не&nbsp;переусложнять код. Вдобавок, ECS сильно упрощает профилирование: сразу видно какая логика (система) сколько времени кадра отнимает, не&nbsp;нужно искать источник лагов в&nbsp;глубине вызовов.</p>

	<h2>Легко управлять данными и логикой</h2>
	<p><b>Добавление новой логики практически безболезненно</b>&nbsp;&mdash; просто вставляешь новую систему в&nbsp;нужное место, не&nbsp;боясь напрямую повлиять на&nbsp;остальной код (стоит отметить, что возможно косвенное влияние через данные). Можно без <nobr>каких-либо</nobr> проблем использовать общую логику (системы) между клиентом и&nbsp;сервером, при сохранении используемых данных (компонентов), конечно. Можно легко переписывать системы, заменяя старые системы на&nbsp;отрефакторенные, при этом без <nobr>какого-либо</nobr> влияния на&nbsp;остальной код, не&nbsp;понравится результат&nbsp;&mdash; просто снова включаешь старую систему и&nbsp;выключаешь новую. Аналогичным механизмом можно легко устраивать A/B тесты.</p>

	<p><b>Всё крутится вокруг данных.</b> На&nbsp;поверку это оказывается дико удобно. С&nbsp;помощью прямого манипулирования данными на&nbsp;сущностях открываются широчайшие возможности для комбинаторики. Можно с&nbsp;помощью данных формировать сущность во&nbsp;что угодно: от&nbsp;камеры, которая убивает по&nbsp;касанию, до&nbsp;нематериального контейнера с&nbsp;конфигами. А&nbsp;если фреймворк предлагает инструментарий для просмотра данных на&nbsp;сущностях, то&nbsp;можно в&nbsp;любой момент изучить данные и&nbsp;их&nbsp;динамику на&nbsp;совершенно любой сущности без необходимости запуска дебаггера, чтобы заглянуть в&nbsp;память.</p>
	<footer>
		Контент взят со <a href="https://habr.com/ru/articles/665276/">статьи на Хабре</a>
	</footer>
</body>

</html>